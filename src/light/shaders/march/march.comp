#version 430 core

struct Vertex
{
	// Vertex position
	vec3 pos;

	// Vertex normal
	vec3 norm;
};

/// A vertex buffer
layout(binding = 0, std430) buffer VertexBuffer
{
	/// Currently writeable buffer index
	uint index;

	/// Chunk origin
	vec3 origin;

	/// Array of geometry vertices
	Vertex vertices[];
} chunk;

/// Marching vertices buffer
layout(binding = 1, std430) buffer MarchingTable
{
	ivec3 edgesTable[256][6];
};

/// Buffer used to read density values
layout(binding = 0, r32f) readonly uniform image3D densityBuffer;

/// Vertices of a [<0,0,0>, <1,1,1>] cube
const ivec3 cubeCorners[] = {
	ivec3(0, 0, 0),
	ivec3(0, 1, 0),
	ivec3(1, 1, 0),
	ivec3(1, 0, 0),
	ivec3(0, 0, 1),
	ivec3(0, 1, 1),
	ivec3(1, 1, 1),
	ivec3(1, 0, 1),
};

/// Generate geometry for voxel
void march(ivec3 voxelIndex)
{
	// Read density values
	float densities[8];
	for (uint i = 0; i < 8; ++i)
		densities[i] = imageLoad(densityBuffer, voxelIndex + cubeCorners[i]).r;

	// Compute marching case
	uint marchingCase
		= (uint(densities[0] > 0.f) << 0)
		| (uint(densities[1] > 0.f) << 1)
		| (uint(densities[2] > 0.f) << 2)
		| (uint(densities[3] > 0.f) << 3)
		| (uint(densities[4] > 0.f) << 4)
		| (uint(densities[5] > 0.f) << 5)
		| (uint(densities[6] > 0.f) << 6)
		| (uint(densities[7] > 0.f) << 7);
	
	// No geometry here
	if (marchingCase == 0x0 || marchingCase == 0xff) return;

	// Pre-compute edge vertices
	vec3 vertPerEdge[12] = {
		vec3(voxelIndex + cubeCorners[0]) + (vec3(cubeCorners[1] - cubeCorners[0]) * (-densities[0]) / (densities[1] - densities[0])),
		vec3(voxelIndex + cubeCorners[1]) + (vec3(cubeCorners[2] - cubeCorners[1]) * (-densities[1]) / (densities[2] - densities[1])),
		vec3(voxelIndex + cubeCorners[2]) + (vec3(cubeCorners[3] - cubeCorners[2]) * (-densities[2]) / (densities[3] - densities[2])),
		vec3(voxelIndex + cubeCorners[3]) + (vec3(cubeCorners[0] - cubeCorners[3]) * (-densities[3]) / (densities[0] - densities[3])),
		
		vec3(voxelIndex + cubeCorners[4]) + (vec3(cubeCorners[5] - cubeCorners[4]) * (-densities[4]) / (densities[5] - densities[4])),
		vec3(voxelIndex + cubeCorners[5]) + (vec3(cubeCorners[6] - cubeCorners[5]) * (-densities[5]) / (densities[6] - densities[5])),
		vec3(voxelIndex + cubeCorners[6]) + (vec3(cubeCorners[7] - cubeCorners[6]) * (-densities[6]) / (densities[7] - densities[6])),
		vec3(voxelIndex + cubeCorners[7]) + (vec3(cubeCorners[4] - cubeCorners[7]) * (-densities[7]) / (densities[4] - densities[7])),

		vec3(voxelIndex + cubeCorners[0]) + (vec3(cubeCorners[4] - cubeCorners[0]) * (-densities[0]) / (densities[4] - densities[0])),
		vec3(voxelIndex + cubeCorners[1]) + (vec3(cubeCorners[5] - cubeCorners[1]) * (-densities[1]) / (densities[5] - densities[1])),
		vec3(voxelIndex + cubeCorners[2]) + (vec3(cubeCorners[6] - cubeCorners[2]) * (-densities[2]) / (densities[6] - densities[2])),
		vec3(voxelIndex + cubeCorners[3]) + (vec3(cubeCorners[7] - cubeCorners[3]) * (-densities[3]) / (densities[7] - densities[3])),
	};

	// Connect edges, generate triangles
	for (uint i = 0; edgesTable[marchingCase][i].x != -1 && i < 6; ++i)
	{
		const ivec3 edges = ivec3(0, 8, 3);

		const uint vertexIndex = atomicAdd(chunk.index, 3);
		for (uint i = 0; i < 3; ++i)
			chunk.vertices[vertexIndex + i].pos = vertPerEdge[edges[i]] / 32.f;
	};
}

layout(local_size_x = 32, local_size_y = 1, local_size_z = 32) in;
void main()
{
	const ivec3 voxelIndex = ivec3(gl_GlobalInvocationID);
	march(voxelIndex);
}