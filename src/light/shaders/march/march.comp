#version 450 core

struct Vertex
{
	// Vertex position
	vec3 pos;

	// Vertex normal
	vec3 norm;
};

/// A vertex buffer
layout(binding = 0, std430) buffer VertexBuffer
{
	/// Currently writeable buffer index
	uint index;

	/// Chunk origin
	vec3 origin;

	/// Array of geometry vertices
	Vertex vertices[];
} chunk;

/// Marching vertices buffer
layout(binding = 1, std430) buffer MarchingTable
{
	int edgesTable[256 * 15];
};
//layout(binding = 0) uniform isampler2D edgesTable;

/// Buffer used to read density values
layout(binding = 0, r32f) readonly uniform image3D densityBuffer;

/// Vertices of a [<0,0,0>, <1,1,1>] cube
const ivec3 cubeCorners[] = {
	ivec3(0, 0, 0),
	ivec3(0, 1, 0),
	ivec3(1, 1, 0),
	ivec3(1, 0, 0),
	ivec3(0, 0, 1),
	ivec3(0, 1, 1),
	ivec3(1, 1, 1),
	ivec3(1, 0, 1),
};

/// Generate geometry for voxel
void march(ivec3 voxelIndex)
{
	// Read density values
	float densities[8];
	for (uint i = 0; i < 8; ++i)
		densities[i] = imageLoad(densityBuffer, voxelIndex + cubeCorners[i]).r;

	// Compute marching case
	uint marchingCase
		= (uint(densities[0] < 0.f) << 0)
		| (uint(densities[1] < 0.f) << 1)
		| (uint(densities[2] < 0.f) << 2)
		| (uint(densities[3] < 0.f) << 3)
		| (uint(densities[4] < 0.f) << 4)
		| (uint(densities[5] < 0.f) << 5)
		| (uint(densities[6] < 0.f) << 6)
		| (uint(densities[7] < 0.f) << 7);

	// No geometry here
	if (marchingCase == 0x0 || marchingCase == 0xff) return;

	// Pre-compute edge vertices
	vec3 vertPerEdge[12] = {
		vec3(voxelIndex) + mix(cubeCorners[0], cubeCorners[1], /* 0.5f */(-densities[0]) / (densities[1] - densities[0])),
		vec3(voxelIndex) + mix(cubeCorners[1], cubeCorners[2], /* 0.5f */(-densities[1]) / (densities[2] - densities[1])),
		vec3(voxelIndex) + mix(cubeCorners[2], cubeCorners[3], /* 0.5f */(-densities[2]) / (densities[3] - densities[2])),
		vec3(voxelIndex) + mix(cubeCorners[3], cubeCorners[0], /* 0.5f */(-densities[3]) / (densities[0] - densities[3])),
		
		vec3(voxelIndex) + mix(cubeCorners[4], cubeCorners[5], /* 0.5f */(-densities[4]) / (densities[5] - densities[4])),
		vec3(voxelIndex) + mix(cubeCorners[5], cubeCorners[6], /* 0.5f */(-densities[5]) / (densities[6] - densities[5])),
		vec3(voxelIndex) + mix(cubeCorners[6], cubeCorners[7], /* 0.5f */(-densities[6]) / (densities[7] - densities[6])),
		vec3(voxelIndex) + mix(cubeCorners[7], cubeCorners[4], /* 0.5f */(-densities[7]) / (densities[4] - densities[7])),

		vec3(voxelIndex) + mix(cubeCorners[0], cubeCorners[4], /* 0.5f */(-densities[0]) / (densities[4] - densities[0])),
		vec3(voxelIndex) + mix(cubeCorners[1], cubeCorners[5], /* 0.5f */(-densities[1]) / (densities[5] - densities[1])),
		vec3(voxelIndex) + mix(cubeCorners[2], cubeCorners[6], /* 0.5f */(-densities[2]) / (densities[6] - densities[2])),
		vec3(voxelIndex) + mix(cubeCorners[3], cubeCorners[7], /* 0.5f */(-densities[3]) / (densities[7] - densities[3])),
	};

	// Connect edges, generate triangles
	for (int i = 0; i < 15; i += 3)
	{
		const uint j = marchingCase * 15 + i;
		const ivec3 edges = ivec3(edgesTable[j], edgesTable[j + 1], edgesTable[j + 2]);
		if (edges[0] < 0) return;

		const uint vertexIndex = atomicAdd(chunk.index, 3);
		chunk.vertices[vertexIndex + 0].pos = vertPerEdge[edges[0]] / 32.f;
		chunk.vertices[vertexIndex + 1].pos = vertPerEdge[edges[1]] / 32.f;
		chunk.vertices[vertexIndex + 2].pos = vertPerEdge[edges[2]] / 32.f;
	};
}

layout(local_size_x = 32, local_size_y = 1, local_size_z = 32) in;
void main()
{
	const ivec3 voxelIndex = ivec3(gl_GlobalInvocationID);
	march(voxelIndex);
}