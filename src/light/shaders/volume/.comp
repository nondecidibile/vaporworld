#version 450 core

uniform float time;
uniform float samplingStep;
uniform ivec2 fboSize;
uniform mat4 projMatrix;
uniform mat4 viewMatrix;

layout(binding = 0) uniform sampler3D volumeData;
layout(binding = 0, rgba32f) writeonly uniform image2D colorBuffer;

/// Local work group setup
layout(local_size_x = 32, local_size_y = 32) in;

float sampleNoise(vec3 p)
{
	return texture(volumeData, p).r;
}

float octaves(vec3 p, int numOctaves)
{
	float f = 1.f;
	float s = 0.5f;
	float v = 0.f;

	for (int i = 0; i < numOctaves; ++i, f *= 2.f, s *= 0.5f)
		v += sampleNoise(p * f) * s;
	
	return v;
}

float monoOctaves(vec3 p, int numOctaves)
{
	float f = 1.f;
	float s = 1.f;
	float v = 0.f;

	for (int i = 0; i < numOctaves; ++i, f *= 2.f, s *= 0.5f)
		v += max(sampleNoise(p * f) * s, 0.f);
	
	return v;
}

float sampleVolume(vec3 traceStart, vec3 traceEnd, float samplingStep, int numSamples)
{
	const vec3 ray	= traceEnd - traceStart;
	const vec3 dir	= normalize(ray);

	float val = 0.f;
	float s = 0.5f;

	for (float t = 1.f; numSamples > 0 && val < 1.f; t += samplingStep, s *= 0.8f, --numSamples)
	{
		const vec3 p = traceStart + t * dir;
		val += sampleNoise(p / 1.f) * s;
	}

	return val;
}

vec3 sampleVolumeRgb(vec3 traceStart, vec3 traceEnd, float samplingStep, int numSamples)
{
	const vec3 ray	= traceEnd - traceStart;
	const vec3 dir	= normalize(ray);
	const float len = length(ray);

	vec3 val = vec3(0.f);
	float s = 0.5f;

	for (float t = 0.7f; numSamples > 0 && t < len; t += samplingStep, s *= 0.9f, --numSamples)
	{
		const vec3 p = traceStart + t * dir;
		val += sampleNoise(p / 4.f) * normalize(0.5f + 0.5f * cos(p)) * s;
	}

	val = min(val, vec3(1.f));
	return val;
}

vec4 sampleVolumeRgba(vec3 traceStart, vec3 traceEnd, float samplingStep, int numSamples)
{
	const vec3 ray	= traceEnd - traceStart;
	const vec3 dir	= normalize(ray);
	const float len = length(ray);

	vec4 val = vec4(0.f);
	float s = 0.5f;

	for (float t = 0.7f; numSamples > 0 && t < len; t += samplingStep, s *= 0.9f, --numSamples)
	{
		const vec3 p = traceStart + t * dir;
		val += sampleNoise(p / 4.f) * vec4(normalize(0.5f + 0.5f * cos(p)), 1.f) * s;
	}

	val = min(val, vec4(1.f));
	return val;
}

void main()
{
	mat4 invProjMatrix = inverse(viewMatrix);
	vec2 clipCoords = vec2(gl_GlobalInvocationID.xy * 2) / vec2(fboSize) - 1.f;
	vec4 nearPlane	= (invProjMatrix * vec4(clipCoords, -1.f, 1.f));
	vec4 farPlane	= (invProjMatrix * vec4(clipCoords, 1.f, 1.f));
	vec3 traceStart	= nearPlane.xyz / nearPlane.w;
	vec3 traceEnd	= farPlane.xyz / farPlane.w;

	/// Compute noise value
	//const float val = sampleVolume(traceStart, traceEnd, 0.12f, 32);
	//imageStore(colorBuffer, ivec2(gl_GlobalInvocationID.xy), vec4(normalize(abs(traceStart) + 1.f)/* vec3(0.3f, 0.6f, 0.933f) */ * val, 1.f));

	const vec4 val = sampleVolumeRgba(traceStart, traceEnd, 0.12f, 40);
	imageStore(colorBuffer, ivec2(gl_GlobalInvocationID.xy), val);
}